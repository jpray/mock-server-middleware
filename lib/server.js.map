{"version":3,"file":"server.js","sourceRoot":"","sources":["../src/server.ts"],"names":[],"mappings":"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","sourcesContent":["import { IncomingMessage } from 'http'\nimport * as _ from 'lodash'\nimport * as url from 'url'\nimport { IMockServerConfig } from '../lib/msm'\nimport { composeModulePath } from './utils'\n\nexport interface IOverride {\n  definition: any\n  once: boolean\n}\n\nexport interface IOverrideStore {\n  [path: string]: IOverride\n}\n\nexport interface ICallLog {\n  method: string\n  href: string\n  search: string\n  query: object\n  pathname: string\n  body?: object\n}\n\nexport default class MSMServer {\n  readonly config: IMockServerConfig\n  readonly overrides: IOverrideStore = {}\n  readonly callLogs: ICallLog[] = []\n  isRecording: boolean = false\n\n  constructor(config: IMockServerConfig) {\n    this.config = config\n  }\n\n  logCall(method: string, calledUrl: url.Url, body?: object) {\n    if (this.isRecording === false) { return }\n    this.callLogs.push({\n      method,\n      href: calledUrl.href,\n      search: calledUrl.search,\n      query: calledUrl.query,\n      pathname: calledUrl.pathname,\n      body,\n    })\n  }\n\n  once(method: string, calledUrl: string, definition: any) {\n    const req: IncomingMessage = { url: calledUrl, method } as any\n\n    this.overrides[composeModulePath(req, this.config)] = {\n      definition,\n      once: true,\n    }\n  }\n\n  on(method: string, calledUrl: string, definition: any) {\n    const req: IncomingMessage = { url: calledUrl, method } as any\n\n    this.overrides[composeModulePath(req, this.config)] = {\n      definition,\n      once: false,\n    }\n  }\n\n  off(method?: string, calledUrl?: string) {\n    if (method != null && calledUrl != null) {\n      const req: IncomingMessage = { url: calledUrl, method } as any\n      delete this.overrides[composeModulePath(req, this.config)]\n      return\n    }\n\n    if (method == null && calledUrl == null) {\n      for (const key in this.overrides) {\n        if (this.overrides.hasOwnProperty(key)) { delete this.overrides[key] }\n      }\n      return\n    }\n\n    throw new Error('Params of msm.server.off() should either be both given or be neither given. '\n      + 'But now only one is given.  This usually indicates a problem in code.')\n  }\n\n  /**\n   * Return a list of all previous requests.\n   * @param pathname - Only return requests with pathname **starts** with this.\n   *                   Use RegExp if you want to match in middle.\n   * @param method - Filter by request method.\n   */\n  called(pathname?: string|RegExp, method?: string): ICallLog[] {\n    return _.filter(this.callLogs, (log) => {\n      if (_.isString(method) && method.toLowerCase() !== log.method) {\n        return false\n      }\n      if (pathname != null && log.pathname.search(pathname as any) !== 0) {\n        return false\n      }\n      return true\n    })\n  }\n\n  /**\n   * Start recording requests.\n   * If recording is already started or previous logs haven't been flushed\n   * it will throw an Error to help prevent potential error in tests.\n   *\n   * You can explicitly pass the log-flush check via the arguments,\n   * but the already-started check is mandatory.\n   *\n   * @param isFlushedCheckBypassed - Bypass log-flush check.\n   * @throws {Error}\n   */\n  record(isLogFlushCheckBypassed: boolean = false): void {\n    if (this.isRecording === true) {\n      throw new Error('MSM is already recording! Check your test code!')\n    }\n    if (!isLogFlushCheckBypassed && this.callLogs.length > 0) {\n      throw new Error('Previous request logs haven\\'t been flushed yet!'\n        + '  If you really want to bypass this check, use `msm.server.record(true)`.')\n    }\n    this.isRecording = true\n  }\n\n  /**\n   * Stop recording requests but not to flush the logs.\n   */\n  stopRecording(): void {\n    this.isRecording = false\n  }\n\n  /**\n   * Stop recording & flush all logs of requests.\n   */\n  flush(): void {\n    this.isRecording = false\n    this.callLogs.length = 0\n  }\n}\n"]}